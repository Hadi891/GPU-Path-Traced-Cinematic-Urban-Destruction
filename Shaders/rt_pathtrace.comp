#version 430 core
layout(local_size_x=8, local_size_y=8) in;

struct RTTriangle {
  vec4 v0; vec4 v1; vec4 v2;
  vec4 n0; vec4 n1; vec4 n2;
};

struct BVHNode {
  vec4 bmin;
  vec4 bmax;
  int leftChild;
  int rightChild;
  int leftFirst;
  int triCount;
};

layout(std430, binding=0) readonly buffer TriBuf { RTTriangle T[]; };
layout(std430, binding=1) readonly buffer NodeBuf { BVHNode N[]; };

layout(binding=0) uniform sampler2D uAlbedo;

layout(rgba32f, binding=0) uniform image2D uAccumOut;

uniform ivec2 uRes;
uniform mat4 uInvView;
uniform mat4 uInvProj;
uniform vec3 uCamPos;

uniform vec3 uSunDir;
uniform vec3 uSunColor;
uniform vec3 uSkyColor;

uniform int uSppPerPass;
uniform int uPassIndex;
uniform int uMaxBounces;

uint wang_hash(uint seed){
  seed = (seed ^ 61u) ^ (seed >> 16u);
  seed *= 9u;
  seed = seed ^ (seed >> 4u);
  seed *= 0x27d4eb2du;
  seed = seed ^ (seed >> 15u);
  return seed;
}
float rnd(inout uint s){
  s = wang_hash(s);
  return float(s) * (1.0 / 4294967296.0);
}

vec3 rayDirFromPixel(ivec2 pix, vec2 jitter){
  vec2 uv = (vec2(pix) + 0.5 + jitter) / vec2(uRes);
  vec2 ndc = uv * 2.0 - 1.0;

  vec4 clip = vec4(ndc, -1.0, 1.0);
  vec4 view = uInvProj * clip;
  view.xyz /= view.w;

  vec3 rdView = normalize(view.xyz);
  vec3 rdWorld = normalize((uInvView * vec4(rdView, 0.0)).xyz);
  return rdWorld;
}

bool rayTri(vec3 ro, vec3 rd, vec3 a, vec3 b, vec3 c, out float tHit, out vec3 nHit){
  vec3 ab = b-a, ac = c-a;
  vec3 p = cross(rd, ac);
  float det = dot(ab, p);
  if (abs(det) < 1e-8) return false;
  float invDet = 1.0 / det;

  vec3 s = ro - a;
  float u = dot(s, p) * invDet;
  if (u < 0.0 || u > 1.0) return false;

  vec3 q = cross(s, ab);
  float v = dot(rd, q) * invDet;
  if (v < 0.0 || (u + v) > 1.0) return false;

  float t = dot(ac, q) * invDet;
  if (t <= 0.0005) return false;

  tHit = t;
  nHit = normalize(cross(ab, ac));
  if (dot(nHit, rd) > 0.0) nHit = -nHit;
  return true;
}

bool rayAABB_TNear(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax, float tMax, out float tNear){
  vec3 inv = 1.0 / rd;
  vec3 t0 = (bmin - ro) * inv;
  vec3 t1 = (bmax - ro) * inv;
  vec3 tmin3 = min(t0, t1);
  vec3 tmax3 = max(t0, t1);

  float lo = max(max(tmin3.x, tmin3.y), tmin3.z);
  float hi = min(min(tmax3.x, tmax3.y), tmax3.z);

  tNear = lo;
  return (hi >= max(lo, 0.0)) && (lo <= tMax);
}

bool traceBVH(vec3 ro, vec3 rd, float tMax, out float tHit, out vec3 nHit, out vec3 pHit){
  float bestT = tMax;
  vec3 bestN = vec3(0.0);

  int stack[64];
  int sp = 0;
  stack[sp++] = 0;

  while (sp > 0) {
    int ni = stack[--sp];
    BVHNode node = N[ni];

    float tNearNode;
    if (!rayAABB_TNear(ro, rd, node.bmin.xyz, node.bmax.xyz, bestT, tNearNode))
      continue;

    if (node.triCount > 0) {
      int first = node.leftFirst;
      int cnt   = node.triCount;
      for (int k = 0; k < cnt; ++k) {
        RTTriangle tri = T[first + k];
        float t; vec3 n;
        if (rayTri(ro, rd, tri.v0.xyz, tri.v1.xyz, tri.v2.xyz, t, n)) {
          if (t < bestT) { bestT = t; bestN = n; }
        }
      }
    } else {
      int L = node.leftChild;
      int R = node.rightChild;

      float tL, tR;
      bool hL = rayAABB_TNear(ro, rd, N[L].bmin.xyz, N[L].bmax.xyz, bestT, tL);
      bool hR = rayAABB_TNear(ro, rd, N[R].bmin.xyz, N[R].bmax.xyz, bestT, tR);

      if (hL && hR) {
        if (tL < tR) { if (sp < 62) { stack[sp++] = R; stack[sp++] = L; } }
        else         { if (sp < 62) { stack[sp++] = L; stack[sp++] = R; } }
      } else if (hL) {
        if (sp < 63) stack[sp++] = L;
      } else if (hR) {
        if (sp < 63) stack[sp++] = R;
      }
    }
  }

  if (bestT >= tMax) return false;
  tHit = bestT;
  nHit = bestN;
  pHit = ro + rd * bestT;
  return true;
}

vec3 sampleHemisphereCos(vec3 N, float u1, float u2){
  float r = sqrt(u1);
  float phi = 6.2831853 * u2;

  vec3 T = normalize(abs(N.y) < 0.99 ? cross(N, vec3(0,1,0)) : cross(N, vec3(1,0,0)));
  vec3 B = cross(N, T);

  vec3 local = vec3(r*cos(phi), sqrt(max(0.0, 1.0-u1)), r*sin(phi));
  return normalize(T*local.x + N*local.y + B*local.z);
}

vec3 envColor(vec3 rd){
  float t = clamp(0.5 * (rd.y + 1.0), 0.0, 1.0);
  return mix(uSkyColor * 0.6, uSkyColor * 1.2, t);
}

float sunVisible(vec3 p, vec3 n){
  vec3 ro = p + n * 0.02;
  vec3 rd = normalize(uSunDir);
  float tH; vec3 nH; vec3 pH;
  bool hit = traceBVH(ro, rd, 1e30, tH, nH, pH);
  return hit ? 0.0 : 1.0;
}

void main(){
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  if (pix.x >= uRes.x || pix.y >= uRes.y) return;

  vec2 uv = (vec2(pix) + 0.5) / vec2(uRes);
  vec3 baseAlbedo = clamp(texture(uAlbedo, uv).rgb, 0.0, 1.0);

  vec3 passSum = vec3(0.0);

  for (int s=0; s<uSppPerPass; ++s) {
    uint seed = uint(pix.x) * 1973u + uint(pix.y) * 9277u + uint(uPassIndex) * 26699u + uint(s) * 104729u;
    vec2 jitter = vec2(rnd(seed) - 0.5, rnd(seed) - 0.5);

    vec3 ro = uCamPos;
    vec3 rd = rayDirFromPixel(pix, jitter);

    vec3 throughput = vec3(1.0);
    vec3 L = vec3(0.0);

    for (int bounce=0; bounce<uMaxBounces; ++bounce) {
      float tH; vec3 nH; vec3 pH;
      if (!traceBVH(ro, rd, 1e30, tH, nH, pH)) {
        L += throughput * envColor(rd);
        break;
      }

      float ndotl = max(0.0, dot(nH, normalize(uSunDir)));
      float vis = sunVisible(pH, nH);
      vec3 direct = uSunColor * ndotl * vis;

      vec3 ambient = uSkyColor * 0.15;

      vec3 albedo = (bounce == 0) ? baseAlbedo : vec3(0.6);
      L += throughput * albedo * (direct + ambient);

      vec3 newDir = sampleHemisphereCos(nH, rnd(seed), rnd(seed));
      ro = pH + nH * 0.02;
      rd = newDir;

      throughput *= albedo;

      throughput = min(throughput, vec3(2.0));
    }

    passSum += L;
  }

  vec3 passCol = passSum / float(uSppPerPass);

  vec4 old = imageLoad(uAccumOut, pix);
  imageStore(uAccumOut, pix, vec4(old.rgb + passCol, 1.0));
}
